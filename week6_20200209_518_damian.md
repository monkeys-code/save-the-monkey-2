# 518. Coin Change 2

출제자: Damian

[Coin Change 2](https://leetcode.com/problems/coin-change-2/)

- 출제 이유
  - DP 문제의 고전이라고 전해들었다. DP에 취약해서...DP와 관련된 유명한 문제들 위주로 공부하고 있었고 풀어보던 중 상당히 마음에 들어서 출제했다. 

---

## Latte
![](./images/20200209_518_latte.jpeg)

- 처음에 문제에 접근할 때 recursive로 각각 함수 호출 시 마다 모든 coin을 한번씩 계산해보고 하는 로직으로 접근했는데, 해당 패턴에 대해서 유효한지 체크하는 로직에 대해서 처리하기가 까다로웠다. 
-  그리고 해당 코드로 리트코드를 제출해봤을 때, 타임아웃이 났다.
-  데미안이 제시해준 솔루션으로 아래와 같이 문제를 해결 할 수 있었다.

```kotlin
fun change(amount: Int, coins: IntArray): Int {
    val dp = IntArray(amount + 1) { if (it == 0) 1 else 0 }

    for (c in coins) 
        for (i in c until dp.size) 
            if (i -c >= 0) 
                dp[i] += dp[i - c]
    
    return dp[amount]
}
```

>P.S 다시풀 때 처음에 문제에 접근한 로직이 다음과 같은데, 아래와 같이 접근한 경우는 중복에 대한 체크를 피할 수 없었다. 근데 여기서 신기한점. 위의 솔루션과 아래의 오답을 비교해보면 차이는 coin을 먼저 도느냐 dp를 먼저 도느냐의 차이인데, 하나는 중복제거, 하나는 중복허용으로 솔루션이 해결되는 것을 볼 수 있다.
>유레카! 다른 곳에서 사용할 수 있을지 잘 모르겠지만 쉽게 함정에 빠지지 않게 도와줄 수 있을 것이다.

```kotlin

fun change(amount: Int, coins: IntArray): Int {
    val dp = IntArray(amount + 1) { if (it == 0) 1 else 0 }

    for (i in 0 until dp.size)
        for (c in coins)
            if (i -c >= 0)
                dp[i] += dp[i - c]

    return dp[amount]
}
```


---

## Damian

- dp 라는 보조 공간을 2d array로 놓고 두는 방법이다. 전형적인 dp 같은 접근이다.
- dp[i][j] 는 i를 사용해서 j를 만들 수 있는 방법의 수를 의미한다. 아래 코드 상에 dp[i][j]를 업데이트 하는 방법과 같이 표현할 수 있는데 간단히 말로 풀어보면 현재 coin을 사용하지 않고 구하는 방법 + 사용해서 이다.

```java
public int change(int amount, int[] coins) {
    int[][] dp = new int[coins.length + 1][amount + 1];
    dp[0][0] = 1;
    
    for (int i = 1; i <= coins.length; i++) {
        dp[i][0] = 1;
        for (int j = 1; j <= amount; j++) {
            dp[i][j] = dp[i - 1][j] + (j >= coins[i - 1] ? dp[i][j - coins[i-1]] : 0);
        }
    }
    return dp[coins.length][amount];
    
}
```
