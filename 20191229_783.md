# 783. Minimum Distance Between BST Nodes

[Link](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)

- 출제 이유
  - Binary Search Tree를 이해하고 있는지 보는 것
  - Tree를 traversal 하는 방법을 이해하고 있는 지 보는 것
    - Recursive
    - Iteratively

## Kevin
![](./images/20191229_783_kevin.jpeg)

---

## Stella
![](./images/20191229_783_stella.jpg)

---

## Tess
![](./images/20191229_783_tess.jpg)

- 기존에 풀던 문제들의 입력값과 달라서 시행착오가 많았다. 이번 기회에 이런 형식에 익숙해질 것.

```python
class Solution(object):
    def minDiffInBST(self, root):
        mymin = 1e9
        prev = None
        curr = root
        start = []
        while curr or start:
            while curr:
                start.append(curr)
                curr = curr.left
                
            curr = start.pop()
            
            if prev != None:
                mymin = min(mymin, abs(curr.val - prev.val))
                
            prev = curr
            curr = curr.right
            
        return mymin
```

---

## Latte
![](./images/20191229_783_latte.jpg)

---

## Damian
- 의도했던 풀이
  - Binary Search Tree의 노드를 inorder traversal 한다.
    - BST를 inorder traversal 하는 것은 정렬된 배열을 앞에서부터 순차적으로 접근하는 것과 같다.
  - 이전에 방문했던 노드의 값을 기억한다. 그리고 그 값과 현재 값의 차이를 구한다. 이 값이 현재 최소값보다 작은 경우 최소값을 업데이트 한다.
- Recursively

```java
private TreeNode previous = null;

private int min = Integer.MAX_VALUE;

public int minDiffInBST(TreeNode root) {
    findMinDiffInBST(root);
    return min;
}

private void findMinDiffInBST(TreeNode root) {
    if (root == null) {
        return;
    }
    findMinDiffInBST(root.left);
    if (previous != null) {
        min = Math.min(min, root.val - previous.val);
    }
    previous = root;
    findMinDiffInBST(root.right);
}
```



- Iteratively

```java
public int minDiffInBST(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode previous = null;
    TreeNode current = root;
    int min = Integer.MAX_VALUE;
    while (current != null || !stack.isEmpty()) {
        while (current != null) {
            stack.push(current);
            current = current.left;
        }
        current = stack.pop();
        if (previous != null) {
            min = Math.min(min, current.val - previous.val);
        }
        previous = current;
        current = current.right;
    }
    return min;
}
```

