# 1. Two Sum

출제자: 케빈

[Link](https://leetcode.com/problems/two-sum/)

- 출제 이유
  - LeetCode 내에서 가장 유명한 문제 중 하나! 첫 시작으로 적절해 보였다 ㅎ.ㅎ
  - 단순하게 풀려면 아주 쉽게 풀 수 있지만, 조금 최적화를 하려면 그리 쉽게 생각나지는 않는다
  - 많은 알고리즘 문제들에서 쓰이는 **메모**의 첫 활용법!

## Damian
![](./images/20191229_1_damian.jpeg)
- 문제 풀이
  - input으로 주어진 nums 배열을 이용해 <값, nums의 index>를 entry로 하는 맵(inverted)을 만든다.
  - 다시 nums 배열을 순회하며 원하는 값이 있는지 확인하고 그 값이 있으면 결과를 반환한다.
  - nums 배열을 한 번 순회하였는데 답을 찾지 못하였을 경우 문제가 잘못된 것이기 때문에 예외를 던진다.
  - 복잡도
    - 시간 복잡도: O(n)
    - 공간 복잡도: O(n)
- 아쉬운 점
  - 엣지 케이스를 고려하지 못 했다. 두 번째 nums 배열을 다시 순회하며 답을 찾을 때 자기 자신과 같은 경우는 제외해주어야 했다. 
  - 한 번만 순회하며 풀 수도 있었는데 그러지 못해 아쉽다. 
---

## Stella
![](./images/20191229_1_stella.jpeg)

---

## Tess
![](./images/20191229_1_tess.jpeg)

---

## Latte
![](./images/20191229_1_latte.jpeg)

### 풀이과정

 최초의 컨셉은 target에서 항목을 하나하나 뺀 후의 값이 다시 nums에 존재하는지 확인하는 것이었는데, 이렇게되면 time complexity가 O(n^2)이 된다.
 
 뭔가 더 나은 대안법을 생각하다가 nums의 리스트를 map에 저장한 후에 target에서 특정 값을 뺀 것이 map에 다시 존재하는지 확인해보았다.

```kotlin
class Solution {
    fun twoSum(nums: IntArray, target: Int): IntArray {
        val result = mutableListOf<Int>()
        val map = mutableMapOf<Int,Int>()

        for(i in 0 until nums.size){
            map[nums[i]] = i
        }

        for(i in 0 until nums.size){
            if(map.contains(target-nums[i])){
                result.add(i)
                result.add(map[target-nums[i]]!!)
                return intArrayOf(i,map[target-nums[i]]!!)
            }
        }
        return intArrayOf()
    }
}
```

하지만 이 Solution은 실패했는데, 문제의 조건에서 같은 인덱스를 두 번사용하는 것은 제외해야 했는데, 해당 부분을 수정하고 다시 다듬은 코드는 다음과 같다.

```kotlin
class Solution {
    fun twoSum(nums: IntArray, target: Int): IntArray {
        val map = mutableMapOf<Int,Int>()

        for(i in 0 until nums.size){
            map[nums[i]] = i
        }

        for(i in 0 until nums.size){
            if(map.contains(target-nums[i]) && map[target-nums[i]] != i){
                return intArrayOf(i,map[target-nums[i]]!!)
            }
        }
        return intArrayOf()
    }
}
```

불필요하게 result라는 변수를 두거나 break로 처리하고 뒤에 로직으로 반환하기보다 바로 return 해주는 코드가 조금이나마 time complexity가 적기 때문에 이렇게 수정했다.

> 아무래도 오프라인에서 빌드해볼 수 없게 돌리다보니 명확하지 않은 문법을 사용하거나, 문제의 조건문을 놓치는 등(같은 인덱스 사용불가) 아쉬운 점이 있었다. 코드를 짜고 제출할 때 문제를 다시 읽어보고 완벽한지 재검토하는 프로세스가 필요할 것같다.


---

## Kevin

가장 단순하게 푸는 방법은 brute force하게 하나 하나 다 도는 것이다!!

```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
    for (i in 0.until(nums.size)) {
        for (j in (i + 1).until(nums.size)) {
            if (nums[i] + nums[j] == target) {
                return intArrayOf(i, j)
            }
        }
    }

    return intArrayOf()
}
```

요로케 풀면 space complexity는 **O(1)**이지만 time complexity는 **O(n^2)**이다.

이럴 때 흔히 쓸 수 있는 방법이 space complexity를 희생해서 time complexity를 최적화하는 것인데, **map을 사용해서 지나간 숫자들을 메모해 두는 것이다**.

```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
    val memo = hashMapOf<Int, Int>()
    for (i in 0.until(nums.size)) {
        val complement = target - nums[i]
        if (complement in memo) {
            // 메모에 complement가 있으면 해답을 찾은 것이다
            return intArrayOf(memo[complement]!!, i)
        } else {
            // 없으면 현재 숫자와 인덱스를 메모에 추가해두도록 한다
            memo[nums[i]] = i
        }
    }
    return intArrayOf()
}
```
