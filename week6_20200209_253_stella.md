# Meeting Rooms II

출제자: Stella

[Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

- 출제 이유
  - heap 을 연습해볼 수 있으면서, heap 외의 다른 풀이로 푸는것도 가능한 좋은 문제라고 생각했다.

---

## Kevin
![](./images/20200209_253_kevin.jpeg)


---

## Stella
### solution 1.
- heap 을 이용해서 푸는 방법은 아래와 같다. 
- 미리 interval 들을 start time으로 정렬해둔다. 이 interval을 하나씩 순회하면서, 이전에 방문했던 interval의 end값중 최소값이 현재의 interval의 start 값보다 작은지를 확인하여 overlab발생여부를 확인한다. 그리고 이때마다 필요한 meeting room의 갯수를 하나씩 증가시켜주면 된다. 
- kevin이 time complexity O(n^2)의 풀이를 손쉽게 떠올렸고, 거기에 heap에 대한 힌트만으로 바로 최적화를 시킨다는 점이 놀라웠다.
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0

        free_rooms = []
        intervals.sort(key= lambda x: x[0])

        heapq.heappush(free_rooms, intervals[0][1])

        for i in intervals[1:]:
            if free_rooms[0] <= i[0]:
                heapq.heappop(free_rooms)
            heapq.heappush(free_rooms, i[1])
        return len(free_rooms)
```
### solution 2.
- heap 없이, start time과 end time을 따로 관리하는 방식으로 이 문제를 풀 수도 있다.
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        used_rooms = 0
        start_timings = sorted([i[0] for i in intervals])
        end_timings = sorted(i[1] for i in intervals)
        L = len(intervals)

        end_pointer = 0
        start_pointer = 0

        while start_pointer < L:
            if start_timings[start_pointer] >= end_timings[end_pointer]:
                used_rooms -= 1
                end_pointer += 1
            used_rooms += 1    
            start_pointer += 1   
        return used_rooms
```
